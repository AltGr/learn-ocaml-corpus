<p>
  Encapsulate the type and values given in the template in a module
  named <code>Exp</code>.
</p>

<p>
  To make <code>e</code> abstract, assign a signature to the module
  <code>Exp</code> that makes the type <code>e</code> abstract and
  publish the functions <code>int</code>, <code>mul</code>
  and <code>add</code>.
</p>

<p>
    Given that interface, the only way to build a value of
    type <code>e</code> is to use the
    functions <code>int</code>, <code>mul</code>
    <code>add</code> and <code>to_string</code>.
    Such functions are called <em>smart
    constructors</em> because they perform some smart operations when
    they build values.
</p>

<p>
    These smart constructors enforce the
    invariant that an expression represented by a value of
    type <code>e</code> is always simplified, i.e. it does not contain
    a subexpression of the form <code>e * 1</code>, <code>1 *
    e</code>, <code>e * 0</code>,
    <code>0 * e</code>, <code>0 + e</code> or <code>e + 0</code>.
</p>

<ul>
  <li>
    The following expression should be accepted.
    <pre>Exp.mul (Exp.int 0) (Exp.add (Exp.int 1) (Exp.int 2))</pre>
  </li>
  <li>
    The following expression should be rejected.
    <pre>Exp.EMul (Exp.EInt 0) (Exp.EAdd (Exp.EInt 1) (Exp.EInt 2))</pre>
  </li>
</ul>

<p>
   Unfortunately, turning <code>e</code> into an abstract data type
   prevents the user from pattern matching over values of
   type <code>e</code>. To allow pattern matching while forbidding the
   direct application of data constructors, OCaml provides a mechanism
   called <code>private types</code>.  The interested student can get
   more information about this advanced (off-topic) feature
   <a href="http://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#toc76">here</a>.
</p>
