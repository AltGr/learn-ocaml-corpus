<p>
  In this exercise, we will display black and white images as text,
  where a black dot is printed as a <code>'#'</code> and a white dot
  as a <code>' '</code>.
</p>

<p>
  Instead of using imperative constructs for storing our images,
  images will simply be functions that take an <code>x</code> and
  a <code>y</code> and return a boolean that indicates if the function
  is black or white at this point.

  <br/>

  This is materialized by the <code>image</code> type alias given in
  the prelude.

  <br/>

  We will only use imperative features to display them.
</p>

<ol>
  <li>
    Define a higher order function <code>display_image: int -> int ->
    image -> unit</code> that takes an integer <code>width</code>,
    another one <code>height</code>, a function which takes
    an <code>x</code> and a <code>y</code>, and renders (prints) the
    boolean function as a series of lines, using two
    nested <code>for</code> loops.

    <br/>

    Each line corresponds to a <code>y</code>, the first line printed
    being for <code>y = 0</code>, the last one for <code>y =
      height</code>.

    <br/>

    In each line, the first character printed must be for <code>x =
      0</code>, the last one for <code>x = width</code>. When the
    function result is <code>true</code>, a sharp (<code>'#'</code>)
    must be displayed, and a space otherwise.

    <br/>

  To try your function, the prelude defines sample images and image
  builders.

  <br/>

  For instance, the image <code>disk 5 5 5</code> would be displayed
  as the following ASCII art, when rendered between
  coordinates <code>0 &lt;= x &lt;= 10</code> and <code>0 &lt;= y
  &lt;= 10</code>.
<pre>
     #
  #######
 #########
 #########
 #########
###########
 #########
 #########
 #########
  #######
     #
</pre>

  </li>
  <li>
    Now, we want to blend images to compose complex images from simple
    ones. For this, we will use the <code>blend</code> type given the
    prelude.

    <br/>

    If we take two functions <code>f</code> and <code>g</code>, we
    have that:
    <ul>
      <li>
        <code>Image f</code> <br/>is the blended image looking exactly
        like <code>f</code>.
      </li>
      <li>
        <code>And (Image f, Image g)</code> <br/> is the blended image
        that is black only where both <code>f</code>
        and <code>g</code> are both black.
      </li>
      <li>
        <code>Or (Image f, Image g)</code> <br/> is the blended image that is
        black wherever either <code>f</code> or <code>g</code> or both
        are black.
      </li>
      <li>
        <code>Rem (Image f, Image g)</code> <br/> is the blended image
        that is black wherever <code>f</code> is black and
        <code>g</code> is not.
      </li>
    </ul>

    Write a recursive <code>render : blend -> int -> int ->
    bool</code> function, that tells, for a given <code>x</code>
    and <code>y</code> the boolean color of the point, considering the
    given blended image.
  </li>
  <li>
    Define a function <code>display_blend: int -> int -> blend ->
      unit</code> that takes a <code>width</code>, another
      one <code>height</code>, a blended image, and displays it by
      combining the two previous functions.

    <br/>
    As an example, the blend <code>display_blend 10 10 (Rem
      (Image all_black, Image (disk 5 5 5)))</code> would be displayed as
    the following ASCII art.
<pre>
##### #####
##       ##
#         #
#         #
#         #

#         #
#         #
#         #
##       ##
##### #####
</pre>
  </li>
</ol>

<p>
  <strong>Bonus question:</strong> Did you see that the type
  of <code>render</code> is actually equivalent to <code>blend ->
  image</code>?
</p>
